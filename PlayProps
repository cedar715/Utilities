import java.time.*;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Produces Micrometer suppliers (or any pull-based metric) for
 * "oldest message age" per queue using SEMPv2.
 *
 * Age unit: SECONDS (change toMillis() if you need ms).
 */
public final class QueueOldestAgeMetrics {
  private static final Logger log = LoggerFactory.getLogger(QueueOldestAgeMetrics.class);

  private final QueueMsgQuery queueMsgQuery; // your SEMP wrapper
  private final Clock clock;                 // inject for testability

  public QueueOldestAgeMetrics(QueueMsgQuery queueMsgQuery, Clock clock) {
    this.queueMsgQuery = Objects.requireNonNull(queueMsgQuery, "queueMsgQuery");
    this.clock = Objects.requireNonNull(clock, "clock");
  }

  /**
   * Build a map of {Tags -> Supplier<Number>} for oldest message age (seconds).
   * 'Tags' is whatever your code uses for metric tags.
   */
  public Map<Tags, Supplier<Number>> buildOldestMsgSpoolAgeSuppliers(List<QueueType> queueDetails) {
    return queueDetails.stream().collect(Collectors.toMap(
        this::createQueueTags,
        qt -> () -> fetchOldestAgeSecondsSafe(qt),
        (existing, replacement) -> replacement // on tag collision, keep latest
    ));
  }

  /** Compute oldest message age in SECONDS, clamped to >= 0. */
  private long fetchOldestAgeSecondsSafe(QueueType queueType) {
    try {
      final String vpn = queueType.getInfo().getMessageVpn();
      final String queue = queueType.getName();

      final Optional<MsgVpnQueueMsg> msgOpt = queueMsgQuery.query(new SempQuery()
          .setVpn(vpn)
          .setName(queue));

      if (msgOpt.isEmpty()) return 0L;

      final MsgVpnQueueMsg msg = msgOpt.get();
      final Object spooledTimeRaw = msg.getSpooledTime();
      if (spooledTimeRaw == null) return 0L;

      final Instant spooled = parseSpooledInstant(spooledTimeRaw);
      final Instant now = Instant.now(clock);

      // Guard against clock skew / future timestamps
      final long seconds = Duration.between(spooled, now).getSeconds();
      return Math.max(seconds, 0L);
    } catch (Exception e) {
      // Keep it noisy enough for ops, but not crashy
      log.warn("Failed to get oldest message spool age for queue '{}': {}", queueType.getName(), e.toString());
      return 0L;
    }
  }

  /**
   * Accepts either:
   *  - ISO‑8601 timestamp (e.g., "2025-08-19T12:30:45Z")
   *  - Epoch seconds as string/number (e.g., "1713439201" or 1713439201L)
   */
  private static Instant parseSpooledInstant(Object raw) {
    if (raw instanceof Number) {
      return Instant.ofEpochSecond(((Number) raw).longValue());
    }
    final String s = raw.toString().trim();
    // Heuristic: all digits (optionally with leading '+/-') => epoch seconds
    if (s.matches("^[+-]?\\d{6,}$")) { // 6+ digits to avoid false positives like year-only
      try {
        return Instant.ofEpochSecond(Long.parseLong(s));
      } catch (NumberFormatException ignore) { /* fall through to ISO parse */ }
    }
    try {
      return OffsetDateTime.parse(s).toInstant();
    } catch (DateTimeParseException dtpe) {
      // Last resort: try Instant.parse if broker ever returns pure 'Z' instant
      return Instant.parse(s); // will throw if invalid; caller handles
    }
  }

  // ----- Helpers you already have -----
  private Tags createQueueTags(QueueType queueType) {
    // your existing tag builder
    return /* ... */;
  }

  // ----- Types you already have / wrap -----
  public interface QueueMsgQuery {
    Optional<MsgVpnQueueMsg> query(SempQuery query) throws Exception;
  }

  public static final class SempQuery {
    private String vpn;
    private String name;
    public SempQuery setVpn(String vpn) { this.vpn = vpn; return this; }
    public SempQuery setName(String name) { this.name = name; return this; }
    public String getVpn() { return vpn; }
    public String getName() { return name; }
  }

  public interface MsgVpnQueueMsg {
    /** Either ISO‑8601 string or epoch‑seconds (number/string). */
    Object getSpooledTime();
  }

  public interface QueueType {
    String getName();
    QueueInfo getInfo();
  }

  public interface QueueInfo {
    String getMessageVpn();
  }

  public interface Tags { /* your tag type */ }
}
