import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.common.errors.TimeoutException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.channel.MessageChannels;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.Pollers;
import org.springframework.integration.endpoint.SourcePollingChannelAdapter;
import org.springframework.integration.handler.advice.AbstractRequestHandlerAdvice;
import org.springframework.integration.kafka.outbound.KafkaProducerMessageHandler;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.messaging.Message;
import org.springframework.messaging.PollableChannel;
import org.springframework.util.backoff.FixedBackOff;

import java.util.concurrent.atomic.AtomicLong;

@Slf4j
@Configuration
public class OutboundFlowKafkaConfig {

    private static final long MIN_RESET_INTERVAL_MS = 10_000;
    private final AtomicLong lastResetTime = new AtomicLong(0);

    private final DefaultKafkaProducerFactory<String, String> producerFactory;

    public OutboundFlowKafkaConfig(DefaultKafkaProducerFactory<String, String> producerFactory) {
        this.producerFactory = producerFactory;
    }

    @Bean
    public PollableChannel producerChannel() {
        return MessageChannels.queue("producerChannel", 10_000).getObject();
    }

    /**
     * Poller reads from QueueChannel. If Kafka fails, we stop this poller -> queue stops draining -> backpressure.
     */
    @Bean
    public IntegrationFlow kafkaOutboundFlow(
            @Qualifier("producerChannel") PollableChannel producerChannel,
            KafkaProducerMessageHandler<String, String> kafkaHandler,
            StopOnKafkaFailureAdvice stopOnKafkaFailureAdvice
    ) {
        return IntegrationFlow
                .from(producerChannel, c -> c.poller(Pollers.fixedDelay(0)
                        .maxMessagesPerPoll(100)         // tune
                        .receiveTimeout(1000)            // tune
                        .errorChannel("kafkaPollerErrorChannel")))
                .handle(kafkaHandler, e -> e.advice(stopOnKafkaFailureAdvice))
                .get();
    }

    /**
     * Advice that:
     * - executes send
     * - on failure: rate-limited producer reset (for timeout/network errors)
     * - stops the poller to enforce blocking policy
     */
    @Bean
    public StopOnKafkaFailureAdvice stopOnKafkaFailureAdvice(
            @Qualifier("kafkaOutboundFlow.source") SourcePollingChannelAdapter poller
    ) {
        return new StopOnKafkaFailureAdvice(poller, this::maybeResetProducer);
    }

    private void maybeResetProducer(Throwable t) {
        if (!shouldResetProducer(t)) return;

        long now = System.currentTimeMillis();
        long last = lastResetTime.get();
        if (now - last < MIN_RESET_INTERVAL_MS) return;
        if (!lastResetTime.compareAndSet(last, now)) return;

        try {
            log.warn("Resetting Kafka producer due to {}", t.toString());
            producerFactory.reset();
        } catch (Exception e) {
            log.error("Producer reset failed", e);
        }
    }

    private boolean shouldResetProducer(Throwable t) {
        if (t == null) return false;
        Throwable c = t;
        while (c != null) {
            String name = c.getClass().getSimpleName();
            if (c instanceof TimeoutException
                    || name.contains("Timeout")
                    || name.contains("Network")
                    || name.contains("Disconnect")) {
                return true;
            }
            c = c.getCause();
        }
        return false;
    }

    /**
     * AOP-style advice around Kafka handler.
     */
    public static class StopOnKafkaFailureAdvice extends AbstractRequestHandlerAdvice {

        private final SourcePollingChannelAdapter poller;
        private final java.util.function.Consumer<Throwable> resetFn;

        public StopOnKafkaFailureAdvice(SourcePollingChannelAdapter poller,
                                        java.util.function.Consumer<Throwable> resetFn) {
            this.poller = poller;
            this.resetFn = resetFn;
        }

        @Override
        protected Object doInvoke(ExecutionCallback callback, Object target, Message<?> message) throws Exception {
            try {
                return callback.execute();
            } catch (Exception e) {
                resetFn.accept(e);

                // Stop poller => stop draining QueueChannel => backpressure
                if (poller.isRunning()) {
                    log.error("Kafka send failed. Stopping poller to enforce BLOCK policy. error={}", e.toString());
                    poller.stop();
                }
                throw e;
            }
        }
    }
}
