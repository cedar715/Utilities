his approach is not giving you the true absolute age from when the message was originally published.
It’s giving you a lower-bound age based on how long the same oldest message ID has remained at the head of the queue while there are still messages in it.

How it works step-by-step
First time the logic runs
Your exporter polls SEMP v1 and asks for:
<messages/><oldest/><count/><num-elements>1</num-elements>
You get back the oldest message’s message-id and the queue depth.
Since you’ve never seen this message-id before, the exporter:
Stores it in memory.
Stores “now” as the lastChangeEpoch.
Sets headUnchangedSeconds = 0.
Subsequent polls
Every poll, it asks again for oldest message-id and depth.
If the oldest ID is different from last time:
That means a message was consumed (or purged) from the head.
The head changed → reset timer to 0 and store new message-id.
If the oldest ID is the same:
That means the same message is still stuck at the head.
Increment the headUnchangedSeconds counter as now - lastChangeEpoch.
What you get in Prometheus
headUnchangedSeconds will keep growing as long as the head stays the same.
When the head changes, it resets to zero.
If the queue is empty (count == 0), the metric also resets to zero.
Important limitations
First run is the “clock start”
If a message has been sitting there for hours before you deploy this logic, your counter will still start at 0 on first observation.
You lose all “history” prior to your exporter watching it.
Why it’s still useful
Even though you can’t get the true original publish time in v1, this lower-bound age is still extremely useful for detecting:
Stuck consumers.
Backlogs that aren’t draining.
Queues where the oldest message has been “rotting” for too long.
