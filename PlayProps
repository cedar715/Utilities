// EventMappingConfig.java
@Configuration
@EnableConfigurationProperties
@ConfigurationProperties(prefix = "solace")
@Validated
public class EventMappingConfig {
  @Valid @NotEmpty
  private List<EventMapping> eventMappings = new ArrayList<>();
  @Valid @NotNull
  private LatchProps latch = new LatchProps();

  @Data public static class LatchProps {
    @NotBlank private String keyspace = "solace:latch";
    @Min(1000) private long refreshInterval = 5000; // ms
  }

  @Data public static class EventMapping {
    @NotBlank private String problem;
    @NotBlank private String clear;
    @NotBlank private String metric;
    @Min(0) private long ttl = 0;             // seconds; 0 disables TTL
    @NotEmpty private List<@NotBlank String> labels;
  }

  public Optional<EventMapping> findByEvent(String eventName) {
    return eventMappings.stream()
        .filter(m -> m.getProblem().equals(eventName) || m.getClear().equals(eventName))
        .findFirst();
  }

  public boolean isProblem(EventMapping m, String eventName) {
    return m.getProblem().equals(eventName);
  }

  public List<EventMapping> all() { return eventMappings; }
  public LatchProps latchProps() { return latch; }

  @PostConstruct
  void validateNoDuplicates() {
    var seen = new HashSet<String>();
    for (var m : eventMappings) {
      if (!seen.add(m.getProblem()))
        throw new IllegalStateException("Duplicate problem event: " + m.getProblem());
      if (!seen.add(m.getClear()))
        throw new IllegalStateException("Duplicate clear event: " + m.getClear());
    }
  }
}
