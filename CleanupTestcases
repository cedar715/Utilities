import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import java.nio.file.Path;
import java.nio.file.Files;
import java.time.LocalDateTime;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class FileCleanupServiceTest {
    @Mock
    private FileConfig fileConfig;
    
    @Mock
    private MeterRegistry meterRegistry;
    
    @Mock
    private Counter deletedFilesCounter;
    
    @Mock
    private Timer.Sample timerSample;
    
    private FileCleanupService cleanupService;
    
    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        
        when(fileConfig.getOutputDirectory()).thenReturn(tempDir.toString());
        when(fileConfig.getDeleteFilePattern()).thenReturn(".tmp");
        when(fileConfig.getRetentionDays()).thenReturn(7);
        when(fileConfig.getCleanupLimit()).thenReturn(100);
        
        when(meterRegistry.counter(eq("cleanup.errors"))).thenReturn(mock(Counter.class));
        when(Counter.builder(eq("cleanup.files.deleted")))
            .thenReturn(mock(Counter.Builder.class));
            
        cleanupService = new FileCleanupService(fileConfig, meterRegistry);
    }

    @Test
    void cleanupOldFiles_Success() throws Exception {
        // Create test files
        Path oldFile = createTempFile("old", ".tmp", -10);
        Path newFile = createTempFile("new", ".tmp", -1);
        Path nonMatchingFile = createTempFile("other", ".txt", -10);

        cleanupService.cleanupOldFiles();

        assertFalse(Files.exists(oldFile), "Old file should be deleted");
        assertTrue(Files.exists(newFile), "New file should not be deleted");
        assertTrue(Files.exists(nonMatchingFile), "Non-matching file should not be deleted");
        
        verify(meterRegistry, never()).counter(eq("cleanup.errors"));
    }

    @Test
    void cleanupOldFiles_RespectsLimit() throws Exception {
        // Create more files than the limit
        when(fileConfig.getCleanupLimit()).thenReturn(2);
        
        Path[] oldFiles = new Path[5];
        for (int i = 0; i < 5; i++) {
            oldFiles[i] = createTempFile("old" + i, ".tmp", -10);
        }

        cleanupService.cleanupOldFiles();

        int deletedCount = 0;
        for (Path file : oldFiles) {
            if (!Files.exists(file)) {
                deletedCount++;
            }
        }

        assertEquals(2, deletedCount, "Should only delete up to the limit");
    }

    @Test
    void cleanupOldFiles_HandlesDeletionFailure() throws Exception {
        Path oldFile = createTempFile("old", ".tmp", -10);
        // Make the file non-deletable (implementation-dependent)
        oldFile.toFile().setWritable(false);

        cleanupService.cleanupOldFiles();

        verify(meterRegistry).counter(eq("cleanup.errors"));
    }

    @Test
    void cleanupOldFiles_NoMatchingFiles() throws Exception {
        createTempFile("new", ".txt", -1);

        cleanupService.cleanupOldFiles();

        verify(meterRegistry, never()).counter(eq("cleanup.errors"));
    }

    @Test
    void isOlderThan_HandlesIOException() throws Exception {
        Path nonExistentPath = tempDir.resolve("nonexistent.tmp");
        
        cleanupService.cleanupOldFiles();

        verify(meterRegistry, never()).counter(eq("cleanup.errors"));
    }

    private Path createTempFile(String prefix, String suffix, int daysOffset) throws Exception {
        Path file = Files.createTempFile(tempDir, prefix, suffix);
        Files.setLastModifiedTime(file, 
            FileTime.from(LocalDateTime.now().plusDays(daysOffset)
                .toInstant(ZoneOffset.UTC)));
        return file;
    }
}
