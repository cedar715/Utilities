import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import io.micrometer.core.instrument.Timer;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import java.nio.file.Path;
import java.nio.file.Files;
import java.time.LocalDateTime;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class FileCleanupServiceTest {
    @Mock
    private FileConfig fileConfig;
    
    private MeterRegistry meterRegistry;
    
    @Mock
    private Counter deletedFilesCounter;
    
    @Mock
    private Timer.Sample timerSample;
    
    private FileCleanupService cleanupService;
    
    @TempDir
    Path tempDir;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        
        // Use SimpleMeterRegistry instead of mocking
        meterRegistry = new SimpleMeterRegistry();
        
        when(fileConfig.getOutputDirectory()).thenReturn(tempDir.toString());
        when(fileConfig.getDeleteFilePattern()).thenReturn(".tmp");
        when(fileConfig.getRetentionDays()).thenReturn(7);
        when(fileConfig.getCleanupLimit()).thenReturn(100);
        
        // Mock Timer.Sample static method
        try (MockedStatic<Timer> timerMock = mockStatic(Timer.class)) {
            timerMock.when(() -> Timer.start(meterRegistry)).thenReturn(timerSample);
            
            cleanupService = new FileCleanupService(fileConfig, meterRegistry);
        }
    }

    @Test
    void cleanupOldFiles_Success() throws Exception {
        // Create test files
        Path oldFile = createTempFile("old", ".tmp", -10);
        Path newFile = createTempFile("new", ".tmp", -1);
        Path nonMatchingFile = createTempFile("other", ".txt", -10);

        try (MockedStatic<Timer> timerMock = mockStatic(Timer.class)) {
            timerMock.when(() -> Timer.start(meterRegistry)).thenReturn(timerSample);
            
            cleanupService.cleanupOldFiles();

            assertFalse(Files.exists(oldFile), "Old file should be deleted");
            assertTrue(Files.exists(newFile), "New file should not be deleted");
            assertTrue(Files.exists(nonMatchingFile), "Non-matching file should not be deleted");
        }
    }

    private Path createTempFile(String prefix, String suffix, int daysOffset) throws Exception {
        Path file = Files.createTempFile(tempDir, prefix, suffix);
        Files.setLastModifiedTime(file, 
            FileTime.from(LocalDateTime.now().plusDays(daysOffset)
                .toInstant(ZoneOffset.UTC)));
        return file;
    }
}
